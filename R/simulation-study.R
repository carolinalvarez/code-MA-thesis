#' Author: Carolina Alvarez
#' Date: 16.02.2023
#' 
#' 
#' Data Generation Process following Fithian and Hastie 
#'
#' Generates data set that is flexible in amount of imbalance, size of training set and class overlapping 
#' (?) also distribution from which coufounders are drawn 
#' I think this will make the class overlapping flexible in the mean parameters?
#' parameter c: the proportion of 0's we want in the data


gdp.imbalanced <- function(N
                           , r
                           , distribution
                           , k
                           , mean1
                           , mean0
                           , sd1
                           , sd0) {
  
  n_class1 <- ceiling(N * (1-r))
  n_class0 <- ceiling(N * r)
  
  y0 <- rep(0, n_class0)
  y1 <- rep(1, n_class1)
  
  if (distribution=="gaussian"){
    X_class1 <- replicate(k, rnorm(n_class1, mean = mean1, sd=sd1))
    X_class1 <- cbind(y1, X_class1)
    
    X_class0 <- replicate(k, rnorm(n_class0, mean = mean0, sd = sd0))
    X_class0 <- cbind(y0, X_class0)
    
    df <- as.data.frame(rbind(X_class1, X_class0))
    
    colnames(df) <- c("y", paste0("X", 1:k))
    
    return(df)
    
  }
  else{
    stop("Distribution not allowed.")
  }
  
}

set.seed(123)

df <- gdp.imbalanced(N = 10000, r = 0.8, distribution= "gaussian", k=5, mean1=1.5, mean0=0, sd1=1, sd0=1)


table(df$y)

# set.seed(123)
# 

#' Case-Control subsampling by Fithian and Hastie 
#'
#' Algorithm for subsampling and fitting a logistic regression in the data
#' hyperparameter a(y): the proportion of 1's we want to subsample. The subsample is generated by first generating 
#' ui ~ U(0,1) that is mutually intedepndent from the pilot (?), the data and each other. Then zi ~ 1 if ui<=a(yi)


cc_algorithm <- function(data, c){
  k <- length(data) - 1 #we take "y" out
  
  selection_bias <- log(c/(1-c))
  
  prob_function <- function(data, c){
    
    data$a <- ifelse(data$y == 0, 1 - c, c)
    
    return(data)
  }
  
  tmp01 <- prob_function(data, c)
  
  U <- runif(nrow(data), 0, 1)
  tmp01$U <- U
  
  tmp01$Z <- NA
  tmp01$Z <- ifelse(tmp01$U <= tmp01$a, 1, 0)
  
  tmp02 <- tmp01[tmp01$Z==1, ] #subsample
  
  xvars <- paste("X", 1:k, sep="")
  
  model_subsample <- glm(as.formula(paste("y ~ ", paste(xvars, collapse= "+")))
                         , data= tmp02
                         , family = binomial) #imp: remove a to avoid perfect separation and convergence issues
  
  coef_unadjusted <- as.vector(model_subsample$coefficients)
  
  beta0_adjusted <- coef_unadjusted[1] - selection_bias
  
  coef_adjusted <- c(beta0_adjusted, coef_unadjusted[2:(k+1)])
  
  res <- list("subsample_S" = tmp02
              , "coef_unadjusted" = coef_unadjusted
              , "coef_adjusted" = coef_adjusted)
  
  return(res)
  
}

cc_output <- cc_algorithm(df, 0.8)
tmp02 <- cc_output$subsample_S
coef_unadjusted <- cc_output$coef_unadjusted
coef_adjusted <- cc_output$coef_adjusted


#showing behaviour of tunning parameter b

library(ggplot2)

# Grid of values for r and c
grid <- expand.grid(r = seq(0.1, 0.9, 0.1), c = seq(0.1, 0.9, 0.1))

# Initialize plot
ggplot() +
  labs(x = "X", y = "g(X)") +
  theme_bw()

# Iterate through grid
for (i in 1:nrow(grid)) {
  # Generate imbalanced data
  data <- gdp.imbalanced(N = 10000, r = grid$r[i], distribution = "gaussian",
                         k = 5, mean1 = 1.5, mean0 = 0, sd1 = 1, sd0 = 1)
  # Calculate adjusted coefficients
  res <- cc_algorithm(data, c = grid$c[i])
  # Calculate adjusted log-odds function
  x <- seq(-5, 5, 0.1)
  g <- res$coef_adjusted[1] + res$coef_adjusted[-1] %*% t(x)
  # Add to plot
  ggplot() +
    labs(x = "X", y = "g(X)") +
    theme_bw() +
    geom_line(aes(x = x, y = g, color = paste0("r=", grid$r[i], ", c=", grid$c[i])), size = 0.8)
}




# Set range of values for r and c
r_vals <- seq(0.05, 0.95, by = 0.05)
c_vals <- seq(0.05, 0.95, by = 0.05)

# Create grid of all possible combinations of r and c
grid <- expand.grid(r = r_vals, c = c_vals)
grid$g <- format(grid$g, scientific = FALSE)


# Calculate g for each combination of r and c
grid$g <- log(grid$r/(1-grid$r)) + log(grid$c/(1-grid$c))

# Create heatmap of g values
ggplot(grid, aes(x = r, y = c, fill = g)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  xlab("r") +
  ylab("c") +
  ggtitle("Heatmap of g values for different combinations of r and c")

plot_ly(x=grid$r, y=grid$c, z=grid$g, type="scatter3d", mode="markers", color=grid$g)

